MODULE server

    !==== variables ====!

    VAR socketdev server_socket;
    VAR socketdev client_socket;
    
    ! port values
    VAR string ipAddress := "192.168.125.1"; ! local host
    VAR num port := 1025;

    ! process variables
    VAR string message := "";
    VAR robtarget hand_frame; 
    VAR num message_index := -1;
    
    VAR robtarget cup_end_frame := [ [0, 0, 0], [0, 0, 0, 0], [1, 1,
0, 0], [ 11, 12.3, 9E9, 9E9, 9E9, 9E9] ];
    
 ! Open socket connection
    PROC server_init() !runs once in initzilise
        !can close socket even if they are not created!
        SocketClose server_socket;
        SocketClose client_socket;
        
        !create sockets
        SocketCreate server_socket;
        
        !connect client and server
        socketBind server_socket, ipAddress, port;
        SocketListen server_socket;
        SocketAccept server_socket,client_socket\ClientAddress:=ipAddress;
        TPWrite ("client connected");
        !have_communication := TRUE;

    ERROR ! we use and expect errors in rapid,
        IF ERRNO=ERR_SOCK_TIMEOUT THEN
            RETRY;
        ELSEIF ERRNO=ERR_SOCK_CLOSED THEN
            RETURN;
        ENDIF
    ENDPROC

    ! hold comminication while client is connected
    ! close communication if timer runs out or clinet close communication
    PROC single_client_communication() ! only want one clinet, therefore we do not need to open other ports and arange new connections!

        ! while we want to have a communication we keep on having one
        WHILE TRUE DO

            SocketReceive client_socket \Str := message;
            ! swich case
            TEST message 
                
                CASE "Connection_test":
                    TPWrite("[INFO] client is sending test message");
                    SocketSend client_socket \Str:= "Connection_Confirmed";
                
                CASE "Cups_available":
                
                    TPWrite("[INFO] client have found cups"); 
                    MovingCups;
                    
                    SocketClose client_socket;
                    RETURN; !break process
                    
                CASE "Coordinates":
                    TPWrite "[INFO] clinet want cordinates";
                    hand_frame := CRobT(\Tool:= tool0 \WObj:= wobj0);
                    SocketSend client_socket \Str :=  RobtargetToString(hand_frame) + "_ack";! add real cordinates here
                          
                CASE "Move":
                    MoveRob(GetRobTarget());  !start move sequence
                            
                CASE "Change_end_target":
                 
                    SocketSend client_socket \Str :=  "Ack_Change_end_target";! add real cordinates here
                    cup_end_frame := GetRobTarget();
                
                CASE "Gripp":
                 SocketSend client_socket \Str:= "Ack_wait";
                 !grip function
                 SocketSend client_socket \Str:= "Ack_Gripp done";
                
                CASE "Release":  
                 SocketSend client_socket \Str:= "Ack_wait";
                 !Release function
                 SocketSend client_socket \Str:= "Ack_Release done";
                 
                DEFAULT:
                 TPWrite "[INFO] message from client: "+message;
                 SocketSend client_socket \Str := "default_"+message;! add real cordinates here
            ENDTEST
           
            WaitTime(0.1);
            SocketSend client_socket \Str:= "Ask_next";

        ENDWHILE

    ERROR ! if errors occure during run
        IF ERRNO = ERR_SOCK_CLOSED THEN ! clinet closed connection before sending end ack!
            server_init;
            RETRY;
        ELSEIF ERRNO = ERR_SOCK_TIMEOUT THEN
            RETRY;
        ENDIF
    ENDPROC
    
        ! move robot 
    PROC MoveRob(robtarget target)
        VAR jointtarget joints;
        
        
        SocketSend client_socket \Str:= "Ask_Wait";
                 
        joints := CalcJointT(target,tGripper \WObj:=wobj0);
        
        MoveAbsJ joints ,v100 ,z100,tool0;
        !MoveAbsJ joints ,vmax \T:=5,z100,tool0; ! move tool0 with joints of a duration of 5sec or max speed, with error margen 100z and 
        !MoveJ target,vmax \T:=5,z200,tool0;   
    ERROR
        IF ERRNO = ERR_ROBLIMIT THEN
            SocketSend client_socket \Str:= "[ERROR]can't reach that possition,try again";
            RETURN;
        ENDIF
    ENDPROC
  
    FUNC robtarget GetRobTarget()
        VAR robtarget return_target;
        return_target := CRobT(\Tool:= tool0 \WObj:= wobj0); !init values
        
        SocketSend client_socket \Str:= "Ask_Coordinate";
        
        SocketReceive client_socket \Str := message;
        return_target.trans := rob_coordinates(message);
        SocketSend client_socket \Str:= "Ack_Coordinate";
        WaitTime(0.1);
        SocketSend client_socket \Str:= "Ask_Orientation";
        
        ! expect message [q1,q2,q3,q4] commands next
        SocketReceive client_socket \Str := message;
        return_target.rot := NormilizeRotation(rob_orientation(message));
        SocketSend client_socket \Str:= "Ack_Orientation";
         WaitTime(0.1);
        
        RETURN return_target;
    ENDFUNC
    !Move multiple cups
    PROC MovingCups()
        
        VAR num amount_of_cups := 0;
        VAR bool succeded := FALSE;
        
        VAR robtarget cup_start_frame;
        VAR robtarget cup_end_frame; 
        
        !expect amount of cups
        SocketSend client_socket \Str:= "Ask_amount_of_cups";   
        SocketReceive client_socket \Str := message;
        
        succeded := StrToVal(message,amount_of_cups); ! we got an cup amount
        SocketSend client_socket \Str:= "Ack_amount_of_cups"; 
        
!        IF (cup_end_frame.rot.q1 +cup_end_frame.rot.q2 +cup_end_frame.rot.q3 +cup_end_frame.rot.q4 = 0) THEN !we have not gotten a end frame! 
!            SocketSend client_socket \Str:= "Ask_where_to_place_cup"; 
!            cup_end_frame := GetRobTarget();   
!        ENDIF
        
        !go through all cups
        WHILE(amount_of_cups > 0) DO
            
            WaitTime(0.1);
            SocketSend client_socket \Str:= "Ack_cup_current_position";   
            cup_start_frame := GetRobTarget();
            
            WaitTime(0.1);
            SocketSend client_socket \Str:= "Ack_cup_end_position";   
            cup_end_frame := GetRobTarget();
            
            MoveRob(cup_start_frame); !move robot arm sequence
            
            ! gripp cup
               
            MoveRob(cup_end_frame); !move robot arm sequence
        
            !release cup
            
            WaitTime(0.1);
            SocketSend client_socket \Str:= "Ask_amount_of_cups";   
            
            !expext amount of cups
            SocketReceive client_socket \Str := message;
            succeded := StrToVal(message,amount_of_cups);
        ENDWHILE
        
        
            WaitTime(0.1);
        SocketSend client_socket \Str:= "Ack_stop"; ! no more cups
        
    ENDPROC
    
    
ENDMODULE